{
  "id": "ci:meta.recursive-publishing-engine",
  "version": "1.0",
  "status": "canonical",
  "title": "Recursive Publishing Engine",
  "summary": "Describes the self-documenting system that generates, validates, and evolves the knowledge base using structured markdown and programmatic tooling.",
  "sections": [
    {
      "title": "What It Is",
      "content": "The Recursive Publishing Engine is a self-documenting system that transforms markdown sources and structured concepts into living, evolving documentation. It orchestrates the generation, validation, maintenance, and evolution of the entire Cognitive Infrastructure knowledge base, ensuring consistency between human-readable documents and machine-parsable structured data. This engine serves as a meta-architectural layer that enforces coherence across the repository while allowing controlled evolution of the knowledge structures. It bridges the gap between flexible human authoring and rigorous machine processing, creating a unified representation that serves both human and artificial intelligence consumers. The system follows core principles of Cognitive Infrastructure in its own designâ€”implementing Return-as-Intelligence through versioning, preventing Semantic Drift through validation, and establishing a Semantic Foundation through consistent formats and structures."
    },
    {
      "title": "Why It Matters",
      "content": "The recursive publishing approach addresses several critical problems in knowledge management: 1) Epistemic Integrity: By maintaining parallel representations (.md for humans, .json for machines) and validating their alignment, the system prevents cognitive drift and ensures shared understanding. 2) Versioned Truth: Every concept and pattern is subject to versioned evolution, allowing clear tracking of how understanding develops while maintaining backward compatibility. 3) Structural Receptivity: The repository is designed to incorporate new knowledge without fragmentation, maintaining coherence as the system expands. 4) Return Paths: Through consistent naming, structured indexing, and machine-searchable metadata, the system provides explicit return routes to previously established knowledge. 5) Self-Description: The system documents its own architecture and evolution rules, creating a meta-level awareness that allows it to be understood, maintained, and enhanced recursively. Within Cognitive Infrastructure, this recursive publishing engine exemplifies the principle that intelligence architectures must themselves be subject to the same constraints and patterns they describe. It demonstrates a practical implementation of the SMI Triad (Structure-Memory-Interaction) through its file organization, versioning system, and automated generation processes."
    },
    {
      "title": "How It Works",
      "content": "The recursive publishing process operates through several integrated components. Core Tools: 1) ci-writer.js: Acts as the generation layer, responsible for scanning markdown files for TODO placeholders, retrieving relevant content from source materials, generating structured content based on context and templates, filling in TODOs with consistent, well-formatted content, and ensuring newly generated content follows established patterns. 2) ci-coder.js: Functions as the validation and synchronization layer, handling JSON schema validation against established rules, link checking and repair across documents, GitHub workflow generation and maintenance, component scaffolding for new patterns, concepts, or tools, and pull request creation for automated updates. Process Flow: 1) Source Addition: Authors add new content to the /sources directory as manuscripts, PDFs, or structured excerpts. 2) Detection and Generation: CI-Writer scans the repository for TODO markers in Markdown files, which serve as generation triggers. 3) Content Processing: The system retrieves relevant source text, applies templates, and generates properly formatted content. 4) Parallel Structure Maintenance: For each Markdown file, a corresponding JSON representation is created or updated in the parallel /json directory structure. 5) Validation: CI-Coder validates all JSON files against their schemas, ensuring consistency and adherence to the established knowledge structures. 6) Cross-Reference Management: The system updates related sections across files, maintaining bidirectional links between connected concepts. 7) Publication: Once validated, content becomes available as a trusted reference that can be cited and built upon. Document Hierarchy: knowledge-base-summary.md acts as the root document and orientation point, providing an overview of the entire repository structure and content. Core Concepts are foundational ideas documented in both human-readable and machine-parsable formats. Patterns and Anti-Patterns capture implementation approaches and common pitfalls in structured formats. Canonical Source Documents provide in-depth treatments following a consistent six-layer structure. Meta Documents explain the system's own architecture and evolution rules. Each concept exists simultaneously as a Markdown document optimized for human reading, a JSON representation structured for machine processing, and cross-references maintained automatically between related concepts. TODOs serve as insertion points where the system can add or update content."
    },
    {
      "title": "Evolution Rules",
      "content": "The Recursive Publishing Engine itself must evolve according to these constraints: 1) Documentation First: Any structural changes to the publishing system must first update this meta-document before implementation. 2) Tool Documentation: New tools or scripts must be documented within this engine's description before becoming part of the standard workflow. 3) Semantic Layer Integrity: Changes to content generation logic must be reflected in the JSON schemas and validation rules. 4) Compatibility: Updates to ci-writer.js and ci-coder.js must maintain compatibility with existing document formats to avoid breaking changes. 5) Version Control: All meta-architectural changes must increment the version number of affected components and document the changes in the revision log. 6) Structure-Memory Alignment: File organization and naming conventions must consistently reflect the conceptual organization of the knowledge base. 7) Test-Driven Evolution: New features should include validation tests to ensure they properly maintain the integrity of the knowledge base. 8) Declarative Configuration: Generation rules and validation constraints should be externalized in configuration rather than embedded in code."
    },
    {
      "title": "Revision Log",
      "content": "v1.0 (Apr 2025): Initial canonical meta-entry documenting publishing engine"
    }
  ]
} 