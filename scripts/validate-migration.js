#!/usr/bin/env node

/**
 * validate-migration.js
 * 
 * A script to validate the migration of the Cognitive Infrastructure repositories
 * Checks for consistent frontmatter and migration comments
 * 
 * Usage: node validate-migration.js [--fix] [path]
 * 
 * Options:
 *   --fix    Attempt to fix missing frontmatter and migration comments
 * 
 * generated by CIâ€‘Coder on 2025-04-18 â€“ rationale: verify migration completeness
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Constants for validation patterns
const FRONTMATTER_PATTERN = /^---\s*\n(?:.*\n)+?---\s*\n/;
const MIGRATION_COMMENT_PATTERN = /(<!--\s*migrated\s+from\s+[\w-]+\s+repo\s+on\s+\d{4}-\d{2}\s*-->|<!--\s*Migration\s*Status:\s*(Complete|In Progress|Pending|Not Started)\s*-->)/i;

// Function to extract title from file content or filename
function extractTitleFromFile(content, filePath) {
  // Try to extract title from frontmatter if it exists
  const frontmatterMatch = content.match(/^---\s*\n(?:.*\n)+?---\s*\n/);
  if (frontmatterMatch) {
    const titleMatch = frontmatterMatch[0].match(/title:\s*(.+)/);
    if (titleMatch) return titleMatch[1].trim().replace(/["']/g, '');
  }
  
  // Try to extract title from first heading
  const headingMatch = content.match(/^#\s+(.+)$/m);
  if (headingMatch) return headingMatch[1].trim();
  
  // Fall back to filename
  return path.basename(filePath, path.extname(filePath))
    .replace(/-/g, ' ')
    .replace(/\b\w/g, l => l.toUpperCase());
}

// Function to add frontmatter to a file
function addFrontmatter(content, filePath) {
  const title = extractTitleFromFile(content, filePath);
  const today = new Date().toISOString().split('T')[0];
  
  const frontmatter = `---
title: "${title}"
date: ${today}
draft: false
---

`;
  
  return frontmatter + content;
}

// Function to add migration comment to a file
function addMigrationComment(content, status = 'Complete') {
  const migrationComment = `<!-- Migration Status: ${status} -->\n\n`;
  
  // If the file already has frontmatter, insert after frontmatter
  if (FRONTMATTER_PATTERN.test(content)) {
    return content.replace(FRONTMATTER_PATTERN, match => match + migrationComment);
  } 
  
  // Otherwise, insert at the beginning
  return migrationComment + content;
}

// Function to fix a file
function fixFile(filePath) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let modified = false;
    
    // Check and fix frontmatter
    if (!FRONTMATTER_PATTERN.test(content)) {
      content = addFrontmatter(content, filePath);
      modified = true;
    }
    
    // Check and fix migration comment
    if (!MIGRATION_COMMENT_PATTERN.test(content)) {
      content = addMigrationComment(content);
      modified = true;
    }
    
    // Write changes if modified
    if (modified) {
      fs.writeFileSync(filePath, content, 'utf8');
      return true;
    }
    
    return false;
  } catch (error) {
    console.error(`Error fixing file ${filePath}:`, error.message);
    return false;
  }
}

// Function to validate a single file
function validateFile(filePath, fix = false, showDetails = false) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const hasFrontmatter = FRONTMATTER_PATTERN.test(content);
    const hasMigrationComment = MIGRATION_COMMENT_PATTERN.test(content);
    
    const isValid = hasFrontmatter && hasMigrationComment;
    
    if (!isValid && showDetails) {
      if (!hasFrontmatter) {
        console.log(`âŒ Missing frontmatter in: ${filePath}`);
      }
      if (!hasMigrationComment) {
        console.log(`âŒ Missing migration comment in: ${filePath}`);
      }
    }
    
    // Fix the file if requested and if it's invalid
    if (fix && !isValid) {
      const wasFixed = fixFile(filePath);
      if (wasFixed && showDetails) {
        console.log(`ðŸ”§ Fixed: ${filePath}`);
      }
      return wasFixed ? 'fixed' : 'invalid';
    }
    
    return isValid ? 'valid' : 'invalid';
  } catch (error) {
    console.error(`Error validating file ${filePath}:`, error.message);
    return 'error';
  }
}

// Function to scan a directory recursively
function scanDirectory(dirPath, fix = false, showDetails = false) {
  const results = { valid: 0, invalid: 0, fixed: 0, errors: 0 };
  
  try {
    // Check if directory exists
    if (!fs.existsSync(dirPath)) {
      console.error(`Directory not found: ${dirPath}`);
      return results;
    }
    
    const files = fs.readdirSync(dirPath, { withFileTypes: true });
    
    for (const file of files) {
      const filePath = path.join(dirPath, file.name);
      
      if (file.isDirectory()) {
        // Skip node_modules and .git directories
        if (file.name === 'node_modules' || file.name === '.git') continue;
        
        // Recursively scan subdirectories
        const subResults = scanDirectory(filePath, fix, showDetails);
        results.valid += subResults.valid;
        results.invalid += subResults.invalid;
        results.fixed += subResults.fixed;
        results.errors += subResults.errors;
      } else if (file.name.endsWith('.md')) {
        // Process markdown files
        const status = validateFile(filePath, fix, showDetails);
        
        if (status === 'valid') {
          results.valid++;
        } else if (status === 'fixed') {
          results.fixed++;
        } else if (status === 'invalid') {
          results.invalid++;
        } else {
          results.errors++;
        }
      }
    }
    
    return results;
  } catch (error) {
    console.error(`Error scanning directory ${dirPath}:`, error.message);
    return results;
  }
}

// Main function
function main() {
  // Parse command line arguments
  const args = process.argv.slice(2);
  const showDetails = args.includes('--details');
  const fix = args.includes('--fix');
  
  // Remove flags from args to get paths
  const paths = args.filter(arg => !arg.startsWith('--'));
  
  console.log('ðŸ” Validating migration status across repositories...');
  
  // Base directory for all repositories (parent of meta-stack)
  const baseDir = path.resolve(__dirname, '..', '..');
  
  // Default repositories to scan - using absolute paths within cognitive-infrastructure
  const defaultRepos = [
    path.join(baseDir, 'knowledge-base'),
    path.join(baseDir, 'meta-stack'),
    path.join(baseDir, 'agentic-systems')
  ];
  
  if (showDetails) {
    console.log('Looking in directories:');
    defaultRepos.forEach(dir => console.log(`  - ${dir}`));
  }
  
  // Use provided paths or default repositories
  const dirsToScan = paths.length > 0 ? paths : defaultRepos;
  
  let totalResults = { valid: 0, invalid: 0, fixed: 0, errors: 0 };
  
  // Scan each directory
  for (const dir of dirsToScan) {
    console.log(`Scanning: ${dir}`);
    const results = scanDirectory(dir, fix, showDetails);
    
    totalResults.valid += results.valid;
    totalResults.invalid += results.invalid;
    totalResults.fixed += results.fixed;
    totalResults.errors += results.errors;
  }
  
  // Print summary
  console.log('\nðŸ“Š Validation Summary:');
  console.log(`   âœ… Valid files: ${totalResults.valid}`);
  console.log(`   âŒ Invalid files: ${totalResults.invalid}`);
  
  if (fix) {
    console.log(`   ðŸ”§ Fixed files: ${totalResults.fixed}`);
  }
  
  if (totalResults.errors > 0) {
    console.log(`   âš ï¸ Errors encountered: ${totalResults.errors}`);
  }
  
  // Print usage information
  console.log('\nðŸ“ Usage:');
  console.log('   node validate-migration.js [--details] [--fix] [paths...]');
  console.log('   --details   Show detailed validation results');
  console.log('   --fix       Automatically fix invalid files');
  console.log('   paths...    Optional specific paths to validate');
  
  // Return exit code based on validation results
  process.exit(totalResults.invalid > 0 ? 1 : 0);
}

// Run the main function
main(); 